"""
AI Tagging Service — uses Groq (Llama-3) to extract smart tags and
sentiment from reservation special-request text and dietary preferences.

Key behaviours:
  - Enforces strict JSON output matching CRM-spec tag names.
  - Detects medical / life-threatening allergy language → sentiment = "Urgent".
  - Falls back to a deterministic regex-based tagger when Groq is unavailable.
"""

import json
import logging
import re
from datetime import datetime, timezone

from groq import AsyncGroq, APIError, APITimeoutError

from app.core.config import get_settings
from app.schemas.tagging import SentimentLevel, SmartTagName, SmartTagPayload

logger = logging.getLogger(__name__)

# ── Urgent-keyword detection (pre-LLM safety net) ──────────────────────────

_URGENT_PATTERNS: list[re.Pattern[str]] = [
    re.compile(p, re.IGNORECASE)
    for p in [
        r"\b(anaphyla\w*)\b",
        r"\bepipen\b",
        r"\b(life[- ]?threatening)\b",
        r"\b(severe\s+allerg\w*)\b",
        r"\b(fatal\s+allerg\w*)\b",
        r"\b(allergic\s+shock)\b",
        r"\b(cannot\s+breathe)\b",
        r"\b(throat\s+swell\w*)\b",
        r"\b(emergency\s+allerg\w*)\b",
        r"\b(deadly\s+allerg\w*)\b",
        r"\b(medical\s+alert)\b",
        r"\b(celiac\s+disease)\b",
    ]
]

# ── LLM system prompt ──────────────────────────────────────────────────────

_SYSTEM_PROMPT = """\
You are a restaurant CRM tagging assistant.  Analyze the guest's special
request text and dietary preferences, then return a JSON object with EXACTLY
these fields:

{
  "tags": [],
  "sentiment": "",
  "confidence": 0.0,
  "summary": "",
  "urgent_reason": null
}

RULES:
1. "tags" must ONLY contain values from this list:
   ["VIP", "Celeb", "frequent visitors", "Birthday", "Anniversary",
    "No shows", "Dietary restrictions", "allergies"]
2. "sentiment" must be one of: "Positive", "Neutral", "Negative", "Urgent".
3. If the text mentions ANY medical condition, life-threatening allergy,
   anaphylaxis, epipen, severe allergy, or similar — you MUST set
   sentiment to "Urgent" and explain in "urgent_reason".
4. "confidence" is your confidence in the tag assignment (0.0 to 1.0).
5. "summary" is a one-sentence description of what you found.
6. Return ONLY valid JSON.  No markdown, no explanation outside the JSON.
"""


def _detect_urgent_keywords(text: str) -> str | None:
    """Pre-LLM safety net: scan for urgent medical keywords."""
    for pattern in _URGENT_PATTERNS:
        match = pattern.search(text)
        if match:
            return f"Detected urgent keyword: '{match.group()}'"
    return None


def _build_user_prompt(special_request_text: str, dietary_preferences: str) -> str:
    return (
        f"Special Request: {special_request_text or '(none)'}\n"
        f"Dietary Preferences: {dietary_preferences or '(none)'}"
    )


# ── Deterministic fallback tagger ──────────────────────────────────────────

_FALLBACK_RULES: list[tuple[re.Pattern[str], SmartTagName]] = [
    (re.compile(r"\bvip\b", re.I), SmartTagName.VIP),
    (re.compile(r"\bceleb(rity)?\b", re.I), SmartTagName.CELEB),
    (re.compile(r"\bfrequent\b", re.I), SmartTagName.FREQUENT_VISITORS),
    (re.compile(r"\bbirthday\b", re.I), SmartTagName.BIRTHDAY),
    (re.compile(r"\banniversary\b", re.I), SmartTagName.ANNIVERSARY),
    (re.compile(r"\bno[- ]?show\b", re.I), SmartTagName.NO_SHOWS),
    (re.compile(r"\b(vegan|vegetarian|halal|kosher|gluten[- ]?free|pescatarian|dairy[- ]?free)\b", re.I), SmartTagName.DIETARY_RESTRICTIONS),
    (re.compile(r"\b(allerg\w+|nut[- ]?free|lactose|celiac|intoleran\w+)\b", re.I), SmartTagName.ALLERGIES),
]


def _fallback_tag(special_request_text: str, dietary_preferences: str) -> SmartTagPayload:
    """Regex-based fallback when the LLM is unreachable."""
    combined = f"{special_request_text} {dietary_preferences}"
    tags: list[SmartTagName] = []
    for pattern, tag in _FALLBACK_RULES:
        if pattern.search(combined) and tag not in tags:
            tags.append(tag)

    urgent_reason = _detect_urgent_keywords(combined)
    sentiment = SentimentLevel.URGENT if urgent_reason else SentimentLevel.NEUTRAL

    return SmartTagPayload(
        tags=tags,
        sentiment=sentiment,
        confidence=0.55,
        summary="Generated by deterministic fallback (Groq unavailable).",
        analyzed_at=datetime.now(timezone.utc),
        urgent_reason=urgent_reason,
    )


# ── Main service class ─────────────────────────────────────────────────────

class TaggingService:
    """Calls Groq Llama-3 to analyze reservation text and produce smart tags."""

    def __init__(self) -> None:
        settings = get_settings()
        self._client = AsyncGroq(
            api_key=settings.GROQ_API_KEY,
            timeout=settings.GROQ_TIMEOUT,
        )
        self._model = settings.GROQ_MODEL
        self._max_retries = settings.GROQ_MAX_RETRIES

    async def analyze(
        self,
        special_request_text: str,
        dietary_preferences: str,
    ) -> SmartTagPayload:
        """
        Run AI analysis on guest text.  Falls back to regex tagger on failure.
        """
        combined_text = f"{special_request_text} {dietary_preferences}"

        # Pre-LLM urgent keyword scan (always applied, even if LLM succeeds)
        pre_urgent = _detect_urgent_keywords(combined_text)

        attempt = 0
        last_error: Exception | None = None

        while attempt <= self._max_retries:
            try:
                payload = await self._call_groq(special_request_text, dietary_preferences)

                # Override sentiment to Urgent if pre-scan found medical keywords
                # but the LLM missed it
                if pre_urgent and payload.sentiment != SentimentLevel.URGENT:
                    payload.sentiment = SentimentLevel.URGENT
                    payload.urgent_reason = pre_urgent

                # Ensure allergies tag is present when urgent
                if payload.sentiment == SentimentLevel.URGENT:
                    if SmartTagName.ALLERGIES not in payload.tags:
                        payload.tags.append(SmartTagName.ALLERGIES)

                return payload

            except (APIError, APITimeoutError) as exc:
                attempt += 1
                last_error = exc
                logger.warning(
                    "Groq API attempt %d/%d failed: %s",
                    attempt,
                    self._max_retries + 1,
                    exc,
                )
            except (json.JSONDecodeError, KeyError, ValueError) as exc:
                attempt += 1
                last_error = exc
                logger.warning(
                    "Groq response parse attempt %d/%d failed: %s",
                    attempt,
                    self._max_retries + 1,
                    exc,
                )

        logger.error(
            "All Groq attempts exhausted, falling back to regex tagger. Last error: %s",
            last_error,
        )
        return _fallback_tag(special_request_text, dietary_preferences)

    async def _call_groq(
        self,
        special_request_text: str,
        dietary_preferences: str,
    ) -> SmartTagPayload:
        """Make a single Groq chat-completion call and parse the result."""
        response = await self._client.chat.completions.create(
            model=self._model,
            messages=[
                {"role": "system", "content": _SYSTEM_PROMPT},
                {
                    "role": "user",
                    "content": _build_user_prompt(special_request_text, dietary_preferences),
                },
            ],
            temperature=0.1,
            max_tokens=512,
            response_format={"type": "json_object"},
        )

        raw = response.choices[0].message.content
        data = json.loads(raw)

        # Validate tag names against the CRM spec enum
        valid_tag_values = {t.value for t in SmartTagName}
        validated_tags = [
            SmartTagName(t) for t in data.get("tags", []) if t in valid_tag_values
        ]

        # Validate sentiment
        raw_sentiment = data.get("sentiment", "Neutral")
        try:
            sentiment = SentimentLevel(raw_sentiment)
        except ValueError:
            sentiment = SentimentLevel.NEUTRAL

        confidence = max(0.0, min(1.0, float(data.get("confidence", 0.5))))

        return SmartTagPayload(
            tags=validated_tags,
            sentiment=sentiment,
            confidence=confidence,
            summary=str(data.get("summary", ""))[:500],
            analyzed_at=datetime.now(timezone.utc),
            urgent_reason=data.get("urgent_reason"),
        )
